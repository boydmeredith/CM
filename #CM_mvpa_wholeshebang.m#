%flags determine how classifier wrapper behaves
flags.num_full_iter = 1; % number of times to run the entire classification process, including feature selection
flags.num_results_iter = 10; % number of times to run the post-feature selection classification process (select subset of the data and train/test classifier)
flags.num_iter_with_same_data = 1; % number of times to run the classfication step for a given subset of data
flags.equate_number_of_trials_in_cond_1_and_2 = 1; % equate number of trials in conditions 1 and 2 (RECOMMENDED)
flags.anova_p_thresh = 1;  % p-value threshold for feature selection ANOVA (1 = DON'T PERFORM ANY FEATURE SELECTION)
flags.anova_nVox_thresh = 0; % alternative to specifying p-value threshold; uses top N voxels (0 = DON'T PERFORM ANY FEATURE SELECTION)
flags.perform_second_round_of_zscoring = 1;  % z-score data again immediately prior to classification (because trial selection and TR selection undoes initial z-scoring)
flags.remove_artdetect_outliers = 0; % 1 = remove trials that exhibited movement or global signal artifacts as determined by ArtDetect
flags.artdetect_motion_thresh = 0; % specify ArtDetect bin for motion outliers (requires that custom ArtDetect scripts have already been run to flag outlier trials)
flags.artdetect_global_signal_thresh = 0; % specify ArtDetect bin for global signal outliers (requires that custom ArtDetect scripts have already been run to flag outlier trials)
flags.remove_outlier_trials = 3;  % on-the-fly outlier detection/removal; specify how many std dev from whole brain mean to exclude as outliers (0 = don't exclude any trials)
flags.generate_importance_maps = 0; % 1=generate importance maps based on classification weights (scaled by the mean univariate activity of each condition)
flags.write_data_log_to_text_file=0; % save a .txt file that logs critical classification performance data
flags.save_data_log_as_mat_file =1; % save a .mat file that logs critical classification performance data
flags.optimize_penalty_param = 0; % 1 = peformed nested cross-validation for empirical penalty optimization
flags.scramble = 0;
%class args determine which classifier to use and what it should do
plrArgs.train_funct_name = 'train_pLR';
plrArgs.test_funct_name = 'test_pLR';
plrArgs.penalty = 10;
linsvmArgs.train_funct_name = 'train_svm';
linsvmArgs.test_funct_name = 'test_svm';
% linsvmArgs.kernel_type = 0; %0=linear, 1=polynomial, 2=rbf, 4=sigmoid
polysvmArgs.train_funct_name = 'train_svm';
polysvmArgs.test_funct_name = 'test_svm';
polysvmArgs.kernel_type = 1;
rbfsvmArgs.train_funct_name = 'train_svm';
rbfsvmArgs.test_funct_name = 'test_svm';
rbfsvmArgs.kernel_type =2;
bpArgs.train_funct_name = 'train_bp';
bpArgs.test_funct_name = 'test_bp';
bpArgs.nHidden = 1;
AA_subjs = {'CM004', 'CM008', 'CM010', 'CM013', 'CM019', 'CM020', 'CM021', 'CM025'};

all_subjs = {'CM001','CM003','CM004','CM005','CM006','CM007','CM008','CM009','CM010','CM012','CM013','CM014','CM015','CM016','CM017','CM018','CM019','CM020','CM021','CM022','CM023','CM024','CM025','CM026'};
highEXtoEXClassPerfSubs = {'CM001' ,   'CM005' ,   'CM006'  ,  'CM009' ,   'CM010'   , 'CM012'   , 'CM014' , 'CM015' ,   'CM019' ,   'CM022'    ,'CM023' ,   'CM025'};
highClassPerfSubIdx = [1     4     5     8     9    10    12    13    17    20    21    23];
all_subjs = [1,3:10,12:26];

%EXPT SPECIFIC INFO
expt.studyCondCols = cmSetupConds();
expt.name = 'COUNTERMEASURES';
expt.dir = '/Users/Jesse/fMRI/COUNTERMEASURES/Data/Functional/'; % top-level expt. directory where individual subject folders live
expt.mvpaDirStr = 'mvpa';
expt.dataImgsToUse = 'raw_filenames.mat'; % .mat file containing names of all functional images (must exist for each subject; can be created by running cellstr(SPM.xY.P) on subject's SPM.mat file)
expt.numTpPerRun = 256; % number of TRs per scanning run (coded for fixed value; adjust code structure if variable TR counts across runs)
expt.traintest = {'EXP_only','CM_only','EXP>CM','EXP>CM_first_run','EXP>CM_last_run','CM>EXP','All_runs','EXP>CM_second_run','EXP>CM_third_run', 'All_runs_TEST_CM', 'All_runs_TEST_EX'};
expt.roiName = 'SEPT09_MVPA_MASK_resliced4mm';  % name of mask to be used for voxel selection (can be a small ROI, a whole-brain mask, or anywhere in between)
expt.roiFname = [expt.dir '/Masks/' expt.roiName '.nii']; % specific path to mask file
expt.trWeights = [0 0 .33 .34 .33 0];
expt.nVox_thresh = 0;
expt.subjIdFormat = 'CM%03d';
expt.onsetsFname = 'onsets_mvpa.mat';
expt.trSecs = 2; %used to convert from seconds to TRs
for scram = 0%[0 1]
    flags.scramble = scram
    for pen = [15, 100, 500, 1000]
        plrArgs.penalty = pen;
        CM_run_mvpa_v3_tbm(flags, expt, plrArgs, all_subjs,{'OLD','NEW'}, 1,  '','', '')
        CM_run_mvpa_v3_tbm(flags, expt, plrArgs, all_subjs,{'Hits','CRs'}, 10,  {'EX_hits','EX_CRs','CM_hits','CM_CRs'},{'CM_hits','CM_CRs'}, 'excmhitscrsBal')
        CM_run_mvpa_v3_tbm(flags, expt, plrArgs, all_subjs,{'OLD','NEW'}, 11,  {'EX_hits','EX_CRs','CM_hits','CM_CRs'},{'CM_hits','CM_CRs'}, 'excmhitscrsBal')
        
    end
end